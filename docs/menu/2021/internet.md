# 互联网

## 互联网是如何运作的

- 当用户向服务器发送请求的时候，比如打开浏览器输入`www.bilibili.com`，先DNS域名服务器请求该域名对应的服务器IP地址，然后通过传输层TCP/IP协议把数据打包，网络层确定IP选址和路由选择，一数据帧的方式在数据链路层，在物理层以二进制数据进行传输，通过路由器时，根据路由表计算下一个跳转的路由器IP，直到访问到B站服务器之后，就会从下往上解读二进制数据，获得最终用户请求的数据，然后把用户请求的数据以同样的方式返回客户端，就会展示在客户端B站的页面。

  

## 什么是HTTP

- http就是一种异步获取数据的手段。

- 基于请求-响应模式，客户端发出，服务端响应并返回

- 简单快速，客户端请求时，只需要传送请求方法和路径

- 限制每次连接只处理一个请求

- 无状态，协议对事务处理没有记忆能力，所以有cookie和session

  http报文主要包括起始行，头部字段(合称Header)，消息正文(Body)

- 响应状态码

  **200**：请求成功

  **301**：永久性重定向，该状态码表示请求的资源已经重新分配 URI，以后应该使用资源现有的 URI

  **302**：临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。

  **303**：该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。

  **304**：该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。

  **400**：该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。

  **401**：该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。

  **403**：该状态码表明对请求资源的访问被服务器拒绝了。

  **404**：该状态码表明服务器上无法找到请求的资源。

  **500**：该状态码表明服务器端在执行请求时发生了错误。

  **503**：该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

- get请求与post请求

  get把请求参数拼接在URL后面，post请求把参数放在请求体里

## 浏览器以及工作原理

用户界面就是浏览器窗口用户操作的部分，渲染引擎就是浏览器展示的界面内容，浏览器引擎就是前两者之间用于传递数据

单进程浏览器结构存在很多问题，如果一个线程卡死就会出现整个浏览器无法工作，页面展示也不流畅，目前采用的是多进程结构的浏览器

- 浏览器进程

  可以控制除标签页外的用户界面

- 网络进程

  负责发起和接受网络请求

- GPU进程

  负责整个浏览器界面的渲染

- 插件进程

  负责网站使用的所有插件

- 渲染器进程

  控制显示tab标签内的所有内容

网络进程获取到html数据后，通过IPC把数据传给渲染器进程，解析html，创建DOM树，进行样式计算，根据前两者生成layout tree，生成绘制计算顺序表，根据layout tree和绘制计算顺序表生成layer tree，把这些信息传给合成器线程，栅格化之后生成合成器帧，这个合成器帧传给GPU，进行渲染显示。

## 域名解析服务器DNS

DNS服务器把IP和域名进行了一个对应映射，当你输入`www.bilibili.com`的时候，首先会去找最近的DNS服务器解析这个域名，如果没有就会向上级继续找，直到找到为止，并把对应的IP地址返回给用户，用户用该IP地址去互联网中访问B站服务器并返回数据进行页面展示。

域名就是一连串字符和后缀组成的方便记忆的字符串，`baidu.com`

## HTTPS

https就是在http的基础上通过SSL或者TLS提供加密处理数据、验证对方身份以及数据完整性保护

- 内容进行了加密，中间者没有密钥就无法解读密文，也无法冒充和篡改
- 通过证书认证客户端访问的是自己的服务器

## websocket

websocket可以实现客户端和服务器长久的连接，http协议的生命周期只有一次request和一次response，请求只能是客户端发起，不能是服务端主动发起。当遇到需要每隔一段时间请求服务器最新数据的情况的时候，就会变得非常麻烦，你可以使用ajax轮询的方式，每隔一段时间就建立一次http请求获取最新数据实现，也可以使用long pull的方式，建立连接后直到返回response才结束，结束后再建立连接，前者是阻塞式的，后者是非阻塞式的；但是都要重新建立连接，http协议是无状态的，每次建立连接，客户端和服务器都要进行状态的信息再交流一遍，这是没有必要的，而且服务端非常被动，必须要客户端主动请求才返回结果，而websocket协议下，服务端就会在有新数据的时候，主动把数据返回给客户端。而且只需要建立一次连接，就可以获取源源不断的数据。

## 跨域资源共享 CORS

CORS分为简单请求和非简单请求(后者有预检请求，询问服务器当前网页是否在服务器的许可名单之中，只有得到肯定答复，才会正式发出XMLHttpRequest请求)

`Access-Control-Allow-Origin`字段的值表示接受的请求的域名字段(*表示任意域名的请求都接受)

`Access-Control-Allow-Credentials`表示是否允许发送cookie，如果要发送cookie，`Access-Control-Allow-Origin`字段不能为*

## 内容安全策略CSP

主要是为了避免跨域脚本攻击(XSS)，让浏览器自己禁止注入恶意脚本。

启用SCP方式

- 设置HTTP的`Content Security Policy`头部字段

  1、只能通过外联方式来引用js和css，内联就会报错

  `'Content-Security-Policy': 'default-src http: https:‘`

  2、只能在指定的域下加载文件，同域用self，允许的域添加到该策略

  `'Content-Security-Policy': 'default-src \'self\''`

  ```json
  `'Content-Security-Policy': 'default-src \'self\' https://cdn.bootcss.com/' `
  ```

  3、限制表单

  ```json
  `'Content-Security-Policy': 'default-src \'self\' https://cdn.bootcss.com/; form-action \'self\''`
  ```

- 设置网页的<meta>标签

  ```html
  <meta http-equiv="Content-Security-Policy" content="form-action 'self';">
  ```

## npm script

npm 脚本是在`package.json`文件里的`scripts`对象

```json
{
  // ...
  "scripts": {
    "build": "node build.js"
  }
}
```

`npm run build`等同于`node build.js`

- 这样可以把项目的脚本集中在一个地方，便于统一管理
- 不同项目，只要功能相同，即有同样的对外接口

每次执行`npm run`就会创建一个shell，并执行shell脚本

`*`表示通配符任意文件

`&`表示同时执行，&&表示执行前一个任务成功后才执行下一个任务

## eslint和prettier

eslint是把所有代码规范的规则写好，统一写定在rules中，当代码不符合规则的时候就会报错或者警告，项目开发中用的比较多

prettier是自己形成自己的一套代码规范，符不符合你的想法不一定， 但是你就用我的，肯定也不至于多丑，当然也支持自己配置
:100:
